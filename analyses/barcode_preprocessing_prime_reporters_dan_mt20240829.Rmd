---
title: "Barcode preprocessing - Prime reporter library"
author: 
  - name: "Max Trauernicht"
    email: "m.trauernicht@nki.nl"
    affiliation: "Netherlands Cancer Institute - van Steensel lab"
date: '`r format(Sys.time(), "%d/%m/%Y")`'
output: 
  html_document:
    theme: united
    highlight: pygments
    fig_caption: yes
    code_folding: hide
    df_print: kable
    toc: true
    toc_depth: 4
    toc_float:
      collapsed: false
---
---

### Aim
In this script barcode counts generated by transfection of prime TF reporter libraries will be processed. Quality checks will be carried out to ensure that the barcode counts accurately reflect the correct TF activities.

---

## Setup {.tabset}

<!-- little HTML script to do indentation of the table of contents -->
<script>
    $(document).ready(function() {
      $items = $('div#TOC li');
      $items.each(function(idx) {
        num_ul = $(this).parentsUntil('#TOC').length;
        $(this).css({'text-indent': num_ul * 10, 'padding-left': 0});
      });

    });
</script>

```{css, echo = FALSE}
div.sourceCode {
  overflow-x: hidden;
}
```

### Libraries 

```{r setup, out.width= "80%", fig.align= "center",  warning= FALSE, message=FALSE}
knitr::opts_chunk$set(echo = TRUE)
StartTime <-Sys.time()

# 8-digit Date tag:
Date <- substr(gsub("-","",Sys.time()),1,8) 
# libraries:
library(dplyr)
library(tidyr)
library(tidyverse)
library(ggplot2)
library(plotly)
library(ggpubr)
library(plyr)
library(data.table)
library(ggbeeswarm)
library(viridis)
library(GGally)
library(pheatmap)
```


### Functions

```{r out.width= "80%", fig.align= "center",  warning= FALSE, message=FALSE}
# Custom functions
SetFileName <- function(filename, initials) {
  # Set filename with extension and initials to make filename with date integrated.
  filename <- substitute(filename)
  initials <- substitute(initials)
  filename <- paste0(initials, Date, filename)
  filename
}

# From Fede:
# ggpairs custom functions
corColor <- function(data, mapping, color = I("black"), sizeRange = c(1, 3), ...) {

  x   <- eval_data_col(data, mapping$x)
  y   <- eval_data_col(data, mapping$y)
  r   <- cor(x, y, "pairwise.complete.obs")
  rt  <- format(r, digits = 3)
  tt  <- as.character(rt)
  cex <- max(sizeRange)

  # helper function to calculate a useable size
  percent_of_range <- function(percent, range) {
    percent * diff(range) + min(range, na.rm = TRUE)
  }

  # plot correlation coefficient
  p <- ggally_text(label = tt, mapping = aes(), xP = 0.5, yP = 0.5,
                   size = I(percent_of_range(cex * abs(r), sizeRange)), color = color, ...) +
    theme(panel.grid.minor=element_blank(),
          panel.grid.major=element_blank())

  corColors <- RColorBrewer::brewer.pal(n = 7, name = "RdYlBu")[2:6]

  if (r <= boundaries[1]) {
    corCol <- corColors[1]
  } else if (r <= boundaries[2]) {
    corCol <- corColors[2]
  } else if (r < boundaries[3]) {
    corCol <- corColors[3]
  } else if (r < boundaries[4]) {
    corCol <- corColors[4]
  } else {
    corCol <- corColors[5]
  }

  p <- p +
    theme(panel.background = element_rect(fill = corCol))

  return(p)
}

# Custom ggplot2 themes
theme_classic_lines <- function() {
  theme_pubr(border = T, legend = "top") +
            theme(panel.grid.major = element_line(colour = "#adb5bd", size = 0.1),
                  strip.background = element_rect(fill = "#ced4da"))
    
}

theme_classic_lines_45 <- function() {
  theme_pubr(border = T, legend = "top", x.text.angle = 45) +
            theme(panel.grid.major = element_line(colour = "#adb5bd", size = 0.1),
                  strip.background = element_rect(fill = "#ced4da"))
}

theme_classic_lines_90 <- function() {
  theme_pubr(border = T,legend = "top", x.text.angle = 90) +
            theme(panel.grid.major = element_line(colour = "#adb5bd", size = 0.1),
                  strip.background = element_rect(fill = "#ced4da"))
}

theme_set(theme_classic_lines())

colors_diverse <- c("#264653", "#2a9d8f", "#e9c46a", "#f4a261", "#e76f51")

ggplot_custom <- function(...) ggplot2::ggplot(...) + 
  scale_color_manual(values = colors_diverse) + 
  scale_fill_manual(values = colors_diverse)
```

### Loading data

```{r data import, out.width= "80%", fig.align= "center",  warning= FALSE, message=FALSE}
# Load metadata file that contains all required information about the sequenced samples
metadata_df <- read_csv2("/DATA/usr/m.trauernicht/projects/prime_TF_reporters/data/mt20240829_metadata_dan.csv")
metadata_df_pDNA_old <- read_csv2("/DATA/usr/m.trauernicht/projects/SuRE-TF/data/mt20240528_metadata_all.csv") %>%
  filter(file == "7027_73_pDNA_E2035_CCGCGGTT-TCTGTTGG_S73_barcode_counts.tsv") %>%
  mutate(pDNA = "pMT02")
metadata_df <- rbind.fill(metadata_df, metadata_df_pDNA_old) %>%
  mutate(library = "1+2") 

# Load in barcode counts
bc_files <- paste(metadata_df$path, metadata_df$file, sep = "")
bc_files <- lapply(bc_files, fread, header = FALSE)
## Name files by the combination of sample_id and pDNA
names(bc_files) <- unique(metadata_df$sample_id)

# Import barcode annotation of both libraries
bc_annotation <- read_csv("/DATA/usr/m.trauernicht/projects/SuRE-TF/data/library_design/bc_annotation_combined.csv") %>%
  filter(library == "1+2")
```


### Creating count data frames

```{r cluster_compare, out.width= "80%", fig.align= "center",  warning= FALSE, message=FALSE}
# Generate one long data frame from the list of data frames
bc_df <- bind_rows(bc_files, .id = "sample_id") %>%
  dplyr::select(sample_id, "barcode" = V1, "starcode_counts" = V2)

# Library 1 has barcodes of length 12 while library 2 has barcodes of length 13
# For sequencing samples that have library 1 and 2 mixed I extracted barcodes of length >=12
# So, I will now filter out all barcodes with length >13, because those are not relevant
bc_df$nchar <- nchar(bc_df$barcode)
bc_df <- bc_df %>%
  filter(nchar <= 13)

# Add experiment annotation to the data
bc_df <- bc_df[!is.na(bc_df$sample_id),]
bc_df <- bc_df %>%
  left_join(metadata_df)

# Add barcode annotation (this will make the data table bigger - all barcodes that are not seen will have NA starcode counts)
bc_df <- merge(bc_df, bc_annotation, all = T, by = c("barcode", "library"))

# Assign 0 to NA counts and remove barcodes with wrong lengths
bc_df$starcode_counts[is.na(bc_df$starcode_counts)] <- 0
bc_df_remove <- bc_df %>%
  filter(nchar == 13 & bc_df$library == "1")
bc_df <- anti_join(bc_df, bc_df_remove)
bc_df_remove <- bc_df %>%
  filter(nchar == 12 & bc_df$library == "2")
bc_df <- anti_join(bc_df, bc_df_remove)

# Remove 0 count data (as they potentially introduce noise - we cannot discriminate low expression from too shallowly sequenced barcodes)
bc_df <- bc_df[bc_df$starcode_counts > 0,]

# Compute reads per million to estimate the relative counts in the respective sample
bc_df <- bc_df %>%
  mutate(rpm = ave(starcode_counts, sample_id, pDNA, FUN = function(x) (x) / sum(x) *1e6 ))

bc_df_filt <- bc_df[!is.na(bc_df$tf),]

bc_df_filt <- bc_df_filt %>%
  mutate(reporter_id = paste(tf, spacing, distance, promoter, background, sep = "_")) %>%
  mutate(reporter_id = gsub("bc-[0-9]{1,2}_", "", reporter_id))
```


## Identify barcodes that are present in the mini library and plot their distribution

Aim: Are all barcodes present in the library? If so, are they equally distributed?

```{r out.width= "80%", fig.align= "center",  warning= FALSE, message=FALSE}
## Plot rpm distribution of barcodes per in_bc1 and in_bc5
ggplot(bc_df %>%
         mutate(match = !is.na(tf)),
       aes(x = rpm)) +
  geom_histogram(bins = 100) +
  facet_wrap(~match) +
  theme_pubr() +
  ggtitle("Barcode counts of library with 1 BC per TF (True = matched barcode)")

bc_df_sum <- bc_df %>%
         mutate(match = !is.na(tf))
                
sum(bc_df_sum$starcode_counts[bc_df_sum$match == T])
sum(bc_df_sum$starcode_counts[bc_df_sum$match == F])

## Plot rpm distribution of barcodes per in_bc1 and in_bc5
ggplot(bc_df_sum %>%
         filter(match),
       aes(x = 'all barcodes', y = rpm)) +
  geom_quasirandom() +
  theme_pubr() +
  ggtitle("Counts of all barcodes that should be in pMT02 library") +
  facet_wrap(~sample_id)

ggplot(bc_df_sum %>%
         filter(match) %>%
         mutate(n_bc = as.numeric(ave(barcode, sample_id, FUN = length))) %>%
         distinct(sample_id, n_bc),
       aes(x = sample_id, y = n_bc)) +
  geom_bar(stat = "identity") +
  theme_pubr() +
  ggtitle("Number of barcodes found per sample")
```
Conclusion: All barcodes can be found in both libraries, and the majority of the reads comes from barcodes in the library. Also, the distribution of barcode counts shifts in the cDNA samples compared to the pDNA samples, which probably means that we are looking at real cDNA barcodes. Looks very good.

---

## Plot correlation between cDNA and pDNA barcode counts

Aim: Data quality check: do the counts come from amplifying pDNA or actual cDNA?
```{r read count 2, out.width= "80%", fig.align= "center",  warning= FALSE, message= FALSE}
# I want to show the following:
## 1: Read distribution of matched barcodes vs. unmatched barcode

### a: total read counts per sample
plot_ly(bc_df_filt %>%
         mutate(sum_counts = ave(starcode_counts, sample, FUN = function(x) sum(x))) %>%
         dplyr::select(sample, sum_counts) %>%
         unique(), 
        x = ~sum_counts, y = ~sample, type = 'bar',
             marker = list(color = '#D6D5C9',
                           line = list(color = 'rgb(8,48,107)', width = 1.5))) %>% 
  layout(title = paste("Number of reads per barcode per sample"),
         xaxis = list(title = "Expected number of reads per barcode per sample"),
         yaxis = list(title = "Sample"))

## 2: What is the correlation of the cDNA bc counts with the pDNA bc counts? 
pDNA_all <- bc_df_filt[grep("pDNA_r1_gcf7027", bc_df_filt$sample_id),] %>%
  dplyr::select(barcode, "pDNA" = sample_id, "pDNA_rpm" = rpm) %>%
  mutate(pDNA = "pMT02")


bc_df_filt <- merge(pDNA_all, bc_df_filt, all = T, by = c("barcode", "pDNA"))
bc_df_filt <- bc_df_filt[!is.na(bc_df_filt$sample_id),] %>% drop_na(pDNA_rpm)


ggplot(bc_df_filt %>%
         filter(pDNA == "pMT02"), aes(x = pDNA_rpm, y = rpm)) +
  geom_point(alpha = .2) +
  geom_abline() +
  scale_color_viridis() +
  facet_wrap(~sample_id) +
  ggtitle("cDNA-pDNA correlation: pMT02 library")



# Generate correlation heatmaps
bc_df_i <- bc_df_filt %>%
  dplyr::select(sample_id, rpm, barcode)  %>%
  filter_all(any_vars(!is.na(.))) %>%
  unique() %>%
  spread(sample_id, rpm) %>%
  filter_all(any_vars(!is.na(.))) %>%
  column_to_rownames("barcode")

x <- cor(bc_df_i, method = "pearson", use = "pairwise.complete.obs")

pheatmap(x, border = "black")



cor <- bc_df_filt %>%
  distinct(sample_id, pDNA) %>%
  mutate(cor = "")

for (i in unique(bc_df_filt$sample_id)) {
    if(nrow(bc_df_filt[bc_df_filt$sample_id == i,]) >= 1) {
          cor$cor[cor$sample_id == i] <- stats::cor(bc_df_filt$rpm[bc_df_filt$sample_id == i], 
                                                    bc_df_filt$pDNA_rpm[bc_df_filt$sample_id == i], use = "pairwise.complete.obs")
    }
}

cor <- cor %>%
  na.omit()

bc_df_filt <- merge(bc_df_filt, cor, by = c("sample_id"), all = T)
```
Conclusion: cDNA barcode counts don't correlate with pDNA counts - good! There are some differences between the formats (384, 96, 12-wells). 384-wells seems to have more pDNA bleedthrough, but it doesn't seem a very big issue (cDNA-pDNA Pearson correlation < 0.2).

---


### Normalization of barcode counts:  
Divide cDNA barcode counts through pDNA barcode counts to get activity

```{r normalization, out.width= "80%", fig.align= "center",  warning= FALSE, message=FALSE}
# Compute activity by dividing cDNA bc counts through pDNA bc counts
bc_df_filt$activity <- bc_df_filt$rpm / bc_df_filt$pDNA_rpm

# Remove rows that could not be computed due to too little pDNA counts
bc_df_cDNA <- bc_df_filt %>%
  drop_na(activity)
```


---

## Calculate correlation between barcodes

```{r out.width= "80%", fig.align= "center",  warning= FALSE, message=FALSE}
## Identify and relabel double reporters
bc_df_12 <- bc_df_cDNA %>%
  filter(nchar == 12, library == "1+2")
bc_df_13 <- bc_df_cDNA %>%
  filter(nchar == 13, library == "1+2")
double_reporters <- unique(bc_df_13$reporter_id[bc_df_13$reporter_id %in% bc_df_12$reporter_id])

double_reporters_df <- bc_df_cDNA %>%
  filter(reporter_id %in% double_reporters, library == "1+2", nchar == 13)
double_reporters_df$reporter_id_2 <- paste(double_reporters_df$reporter_id, double_reporters_df$nchar)
bc_df_cDNA$reporter_id_2 <- paste(bc_df_cDNA$reporter_id, bc_df_cDNA$nchar)
bc_df_cDNA <- bc_df_cDNA[!bc_df_cDNA$reporter_id_2 %in% double_reporters_df$reporter_id_2,] %>%
  dplyr::select(-reporter_id_2)
double_reporters_df <- double_reporters_df %>%
  dplyr::select(-reporter_id_2)

double_reporters_df$barcode_number[double_reporters_df$barcode_number == 1] <- 9
double_reporters_df$barcode_number[double_reporters_df$barcode_number == 2] <- 10
double_reporters_df$barcode_number[double_reporters_df$barcode_number == 3] <- 11
double_reporters_df$barcode_number[double_reporters_df$barcode_number == 4] <- 12
double_reporters_df$barcode_number[double_reporters_df$barcode_number == 5] <- 13

bc_df_cDNA <- rbind(bc_df_cDNA, double_reporters_df)

## Combine replicates in 8 different columns
bc_df_rep <- bc_df_cDNA %>% 
  filter(commercial_reporter == "No", rand_promoter == "No", native_enhancer == "No", hPGK == "No", neg_ctrls == "No", is.na(stimulation)) %>%
  filter(sample_id != "pDNA_r1_gcf7027") %>%
  dplyr::select(barcode_number, rpm, sample_id, reporter_id, neg_ctrls, library) %>%
  mutate(activity = log2(rpm)) %>%
  dplyr::select(-rpm) %>%
  spread(barcode_number, activity)
names(bc_df_rep) <- gsub("([1-9]{1})", "Barcode \\1", names(bc_df_rep))


ggscatter(bc_df_rep, x = "Barcode 1", y = "Barcode 2",
                 add = "reg.line",
                 color = "neg_ctrls",
                 size = 0.5,
                 add.params = list(color = "blue", fill = "lightgray"), 
                 title = paste("Correlation barcode 1 vs 2 in BC5 library, per sample"),
                 conf.int = TRUE, ylab = "Activity (log2) barcode 2", xlab = "Activity (log2) barcode 1") + 
    stat_cor(method = "pearson", label.x = -3, label.y = -3) + 
    geom_abline(linetype = "dashed") +
    facet_wrap(~sample_id)


# Correlation matrix plot
n <- sample(1:nrow(bc_df_rep), 1000)
boundaries <- seq(from = 0.8, by = 0.05, length.out = 4)
plt <- ggpairs(bc_df_rep %>% dplyr::select('Barcode 1', 'Barcode 2', 'Barcode 3', 'Barcode 4', 'Barcode 5'),
               upper = list(continuous = corColor),
               lower = list(continuous = function(data, mapping, ...) {
                   ggally_points(data = data[n, ], mapping = mapping, alpha = 0.1, size = 0.5) +
                   geom_abline(slope = 1, lty = "dashed", col = "red") +
                   theme_pubr(border = T)}),
               diag = list(continuous = function(data, mapping, ...) {
                   ggally_densityDiag(data = data, mapping = mapping, alpha = 0.3, fill = "red") +
                   theme_pubr(border = T)})) +
  ggtitle("Correlation Between Technial Replicates - BC5 library") +
  xlab("Reporter activity (log2)") +
  ylab("Reporter activity (log2)")

print(plt)
```
Conclusion: The five barcodes correlate very highly - we can just take the mean.

---


### Calculate mean activity

```{r out.width= "80%", fig.align= "center",  warning= FALSE, message=FALSE}
## Calculate mean per condition and library
bc_df_cDNA_filt <- bc_df_cDNA

# Normalize by negative controls
bc_df_cDNA_neg <- bc_df_cDNA_filt %>%
  filter(tf %in% c("RANDOM1", "RANDOM2", "RANDOM3")) %>%
  distinct(reporter_id, sample_id, activity, promoter) %>%
  mutate(background_activity = ave(activity, sample_id, promoter, FUN = function(x) mean(x, na.rm = T))) %>%
  distinct(background_activity, sample_id, promoter)

bc_df_cDNA_filt <- bc_df_cDNA_filt %>%
  left_join(bc_df_cDNA_neg) %>%
  mutate(activity_minP = activity / background_activity) %>%
  mutate(activity_minP_mean = ave(activity_minP, sample_id, reporter_id, FUN = function (x) mean(x, na.rm = T))) %>%
  mutate(reporter_activity_minP = ave(activity_minP, condition, format, reporter_id, FUN = function (x) mean(x, na.rm = T)))
```

---

## Correlate biological replicates
```{r out.width= "80%", fig.align= "center",  warning= FALSE, message=FALSE}
bc_df_cDNA_filt_cor <- bc_df_cDNA_filt %>%
  distinct(reporter_id, activity_minP_mean, replicate, condition, format) %>%
  mutate(activity_minP_mean = log2(activity_minP_mean)) %>%
  spread(replicate, activity_minP_mean)

ggplot(bc_df_cDNA_filt_cor %>%
         drop_na(format),
       aes(x = `r1`, y = `r2`)) +
  geom_point() +
  facet_wrap(~condition) +
  theme_pubr() +
  ylab("Activity (log2) rep 2") +
  xlab("Activity (log2) rep 1")
```
Conclusion: The biological replicates correlate very highly - we can just take the mean.

---

## Plot VDR activities in all libraries
Aim: Do we see VDR upregulation with all libraries?
```{r out.width= "80%", fig.align= "center",  warning= FALSE, message=FALSE}
ggplot(bc_df_cDNA_filt %>%
         filter(neg_ctrls == "No", native_enhancer == "No", commercial_reporter == "No", condition != "pDNA") %>%
         #filter(tf %in% c("ELK1")) %>%
         mutate(reporter_activity_minP = log2(reporter_activity_minP)) %>%
         distinct(reporter_activity_minP, reporter_id, condition, tf),
       aes(x = condition, y = reporter_activity_minP)) +
  geom_quasirandom() +
  ylab("Activity (log2)") +
  theme_pubr(x.text.angle = 90) +
  facet_wrap(~tf)

bc5_lib <- read_csv("/DATA/usr/m.trauernicht/projects/prime_TF_reporters/library_design/prime_reporter_library.csv") %>%
  mutate(downstream = gsub(".*CACGACGCTCTTCCGATCT", "", sequence)) %>%
  mutate(bc = gsub("(.*)CATCGTCGCATCCAAGAG", "\\1", downstream))

ggplot(bc_df_cDNA_filt %>%
         mutate(tf = gsub("_.*", "", tf)) %>%
         filter(neg_ctrls == "No", native_enhancer == "No", condition != "pDNA") %>%
         filter(!tf %in% c("RANDOM1", "RANDOM2", "RANDOM3")) %>%
         filter(barcode %in% bc5_lib$bc) %>%
         mutate(reporter_activity_minP = log2(reporter_activity_minP)) %>%
         distinct(reporter_activity_minP, reporter_id, condition, tf),
       aes(x = condition, y = reporter_activity_minP)) +
  geom_bar(stat = "identity") +
  ylab("Activity (log2)") +
  theme_pubr(x.text.angle = 90) +
  facet_wrap(~tf)
```
Conclusion: In all libraries there is a clear VDR upregulation (~16-fold, which is less than before). 

